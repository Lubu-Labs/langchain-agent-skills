#!/usr/bin/env node
/**
 * Generate test cases from LangGraph graph structure.
 *
 * This script analyzes a LangGraph graph and generates boilerplate test cases
 * for each node, edge, and end-to-end flow. Useful for quickly scaffolding
 * a comprehensive test suite.
 *
 * Usage:
 *   node generate_test_cases.js <graph_module> [--output <output_dir>] [--framework vitest]
 *
 * Examples:
 *   # Generate vitest test cases for agent in my-agent.ts
 *   node generate_test_cases.js ./my-agent.ts:graph --output tests/
 *
 *   # Generate jest test cases
 *   node generate_test_cases.js ./my-agent.ts:graph --framework jest
 */

import { program } from "commander";
import * as fs from "fs";
import * as path from "path";
import { pathToFileURL } from "url";

/**
 * Load graph from module path
 */
async function loadGraphFromModule(modulePath) {
  try {
    const [moduleFile, attrName] = modulePath.split(":");

    if (!moduleFile || !attrName) {
      console.error(
        "Error: Invalid module path. Use format: ./file.ts:attribute"
      );
      process.exit(1);
    }

    // Resolve absolute path
    const absolutePath = path.resolve(moduleFile);

    if (!fs.existsSync(absolutePath)) {
      console.error(`Error: File not found: ${absolutePath}`);
      process.exit(1);
    }

    // Import module
    const module = await import(pathToFileURL(absolutePath).href);

    if (!(attrName in module)) {
      console.error(
        `Error: Module '${moduleFile}' has no export '${attrName}'`
      );
      process.exit(1);
    }

    return { graph: module[attrName], moduleName: moduleFile, attrName };
  } catch (error) {
    console.error(`Error loading graph: ${error.message}`);
    process.exit(1);
  }
}

/**
 * Extract graph structure
 */
function extractGraphStructure(graph) {
  const structure = {
    nodes: [],
    edges: [],
    conditionalEdges: [],
    entryPoint: null,
  };

  try {
    if (graph.nodes) {
      if (graph.nodes instanceof Map) {
        structure.nodes = Array.from(graph.nodes.keys());
      } else if (typeof graph.nodes === "object") {
        structure.nodes = Object.keys(graph.nodes);
      }
    }

    if (graph.edges) {
      structure.edges = graph.edges;
    }
  } catch (error) {
    console.warn(`Warning: Could not fully extract graph structure: ${error.message}`);
  }

  return structure;
}

/**
 * Generate Vitest test cases
 */
function generateVitestTests(structure, graphModule, graphAttr) {
  const nodes = structure.nodes || [];

  let testCode = `/**
 * Auto-generated test cases for ${graphModule}:${graphAttr}
 *
 * Generated by generate_test_cases.js
 * Edit these tests to add specific assertions and test data.
 */

import { describe, it, expect } from "vitest";
import { ${graphAttr} } from "${graphModule}";

describe("Graph Structure", () => {
  it("should compile without errors", () => {
    expect(${graphAttr}).toBeDefined();
  });

  it("should have expected nodes", () => {
    const expectedNodes = ${JSON.stringify(nodes)};
    // TODO: Verify actual nodes match expected
    expect(expectedNodes.length).toBeGreaterThan(0);
  });
});

`;

  // Generate node tests
  if (nodes.length > 0) {
    testCode += `describe("Node Tests", () => {
`;

    for (const node of nodes) {
      testCode += `  it("should execute ${node} node", () => {
    // TODO: Create appropriate test state
    const testState = {};

    // TODO: Execute node and verify output
    // const result = ${graphAttr}.nodes["${node}"](testState);
    // expect(result).toBeDefined();
  });

`;
    }

    testCode += `});

`;
  }

  // Generate end-to-end tests
  testCode += `describe("End-to-End Tests", () => {
  it("should execute basic flow", async () => {
    // TODO: Create test input
    const testInput = { messages: [] };

    // TODO: Execute graph
    // const result = await ${graphAttr}.invoke(testInput);
    // expect(result).toBeDefined();
  });

  it("should execute with real LLM (integration test)", async () => {
    // Integration test - skip by default
    // Remove skip to run with real LLM
    return; // Skip

    // TODO: Create realistic test input
    const testInput = { messages: [] };

    // TODO: Execute and verify
    // const result = await ${graphAttr}.invoke(testInput);
  });

  it("should execute with mocked LLM", async () => {
    // TODO: Mock LLM responses
    // TODO: Execute graph
    // TODO: Verify the graph flow is correct
  });
});

describe("Error Handling", () => {
  it("should handle empty input", async () => {
    // TODO: Test empty input handling
  });

  it("should handle invalid input", async () => {
    // TODO: Test invalid input handling
  });

  it("should handle LLM errors gracefully", async () => {
    // TODO: Mock LLM to throw errors
    // TODO: Verify graceful error handling
  });
});
`;

  return testCode;
}

/**
 * Generate Jest test cases
 */
function generateJestTests(structure, graphModule, graphAttr) {
  const nodes = structure.nodes || [];

  let testCode = `/**
 * Auto-generated test cases for ${graphModule}:${graphAttr}
 *
 * Generated by generate_test_cases.js
 * Edit these tests to add specific assertions and test data.
 */

import { ${graphAttr} } from "${graphModule}";

describe("Graph Structure", () => {
  it("should compile without errors", () => {
    expect(${graphAttr}).toBeDefined();
  });

  it("should have expected nodes", () => {
    const expectedNodes = ${JSON.stringify(nodes)};
    // TODO: Verify actual nodes match expected
    expect(expectedNodes.length).toBeGreaterThan(0);
  });
});

`;

  // Generate node tests
  if (nodes.length > 0) {
    testCode += `describe("Node Tests", () => {
`;

    for (const node of nodes) {
      testCode += `  it("should execute ${node} node", () => {
    // TODO: Create appropriate test state
    const testState = {};

    // TODO: Execute node and verify output
    // const result = ${graphAttr}.nodes["${node}"](testState);
    // expect(result).toBeDefined();
  });

`;
    }

    testCode += `});

`;
  }

  // Generate end-to-end tests
  testCode += `describe("End-to-End Tests", () => {
  it("should execute basic flow", async () => {
    // TODO: Create test input
    const testInput = { messages: [] };

    // TODO: Execute graph
    // const result = await ${graphAttr}.invoke(testInput);
    // expect(result).toBeDefined();
  });

  it("should execute with real LLM (integration test)", async () => {
    // Integration test - skip by default
    // Remove skip to run with real LLM
    return; // Skip

    // TODO: Create realistic test input
    const testInput = { messages: [] };

    // TODO: Execute and verify
    // const result = await ${graphAttr}.invoke(testInput);
  });

  it("should execute with mocked LLM", async () => {
    // TODO: Mock LLM responses
    // TODO: Execute graph
    // TODO: Verify the graph flow is correct
  });
});

describe("Error Handling", () => {
  it("should handle empty input", async () => {
    // TODO: Test empty input handling
  });

  it("should handle invalid input", async () => {
    // TODO: Test invalid input handling
  });

  it("should handle LLM errors gracefully", async () => {
    // TODO: Mock LLM to throw errors
    // TODO: Verify graceful error handling
  });
});
`;

  return testCode;
}

/**
 * Main function
 */
async function main() {
  program
    .argument("<graph-module>", "Module path to graph (e.g., ./my-agent.ts:graph)")
    .option("-o, --output <dir>", "Output directory for test files", "tests")
    .option(
      "-f, --framework <name>",
      "Test framework to use (vitest or jest)",
      "vitest"
    )
    .parse();

  const options = program.opts();
  const graphModule = program.args[0];

  // Load the graph
  console.log(`Loading graph from ${graphModule}...`);
  const { graph, moduleName, attrName } = await loadGraphFromModule(graphModule);

  // Extract structure
  console.log("Extracting graph structure...");
  const structure = extractGraphStructure(graph);

  console.log(`Found ${structure.nodes.length} nodes`);

  // Generate test code
  console.log(`Generating ${options.framework} test cases...`);
  let testCode;
  let filename;

  if (options.framework === "vitest") {
    testCode = generateVitestTests(structure, moduleName, attrName);
    filename = `${attrName}.test.ts`;
  } else if (options.framework === "jest") {
    testCode = generateJestTests(structure, moduleName, attrName);
    filename = `${attrName}.test.ts`;
  } else {
    console.error(`Error: Unknown framework '${options.framework}'`);
    process.exit(1);
  }

  // Write to file
  const outputDir = path.resolve(options.output);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  const outputFile = path.join(outputDir, filename);
  fs.writeFileSync(outputFile, testCode);

  console.log(`\nâœ… Test cases generated: ${outputFile}`);
  console.log("\nNext steps:");
  console.log("1. Review the generated tests");
  console.log("2. Add specific test data and assertions");
  console.log("3. Implement LLM mocking as needed");
  console.log(`4. Run tests: ${options.framework} ${outputFile}`);
}

main().catch((error) => {
  console.error("Fatal error:", error);
  process.exit(1);
});
