#!/usr/bin/env python3
"""
Generate test cases from LangGraph graph structure.

This script analyzes a LangGraph graph and generates boilerplate test cases
for each node, edge, and end-to-end flow. Useful for quickly scaffolding
a comprehensive test suite.

Usage:
    python generate_test_cases.py <graph_module> [--output <output_dir>] [--framework pytest]

Examples:
    # Generate pytest test cases for agent in my_agent.py
    python generate_test_cases.py my_agent.graph --output tests/

    # Generate test cases using unittest framework
    python generate_test_cases.py my_agent.graph --framework unittest
"""

import argparse
import importlib
import importlib.util
import re
import sys
from pathlib import Path
from typing import Any, Dict, List


def load_graph_from_module(module_path: str):
    """Load a graph object from a Python module path."""
    try:
        # Split module path into module and attribute
        if ":" in module_path:
            module_name, attr_name = module_path.split(":")
        else:
            parts = module_path.rsplit(".", 1)
            if len(parts) == 2:
                module_name, attr_name = parts
            else:
                print(f"Error: Invalid module path '{module_path}'")
                print("Use format: module.path:attribute or module.path.attribute")
                sys.exit(1)

        # Load the module
        spec = importlib.util.find_spec(module_name)
        if spec is None:
            print(f"Error: Could not find module '{module_name}'")
            sys.exit(1)

        module = importlib.import_module(module_name)

        # Get the graph attribute
        if not hasattr(module, attr_name):
            print(f"Error: Module '{module_name}' has no attribute '{attr_name}'")
            sys.exit(1)

        graph = getattr(module, attr_name)
        return graph, module_name, attr_name

    except Exception as e:
        print(f"Error loading graph: {e}")
        sys.exit(1)


def extract_graph_structure(graph) -> Dict[str, Any]:
    """Extract nodes, edges, and entry point from a compiled graph."""
    structure = {
        "nodes": [],
        "edges": [],
        "conditional_edges": [],
        "entry_point": None,
    }

    try:
        # Try to access graph internals (LangGraph-specific)
        if hasattr(graph, "nodes"):
            structure["nodes"] = list(graph.nodes.keys())

        if hasattr(graph, "edges"):
            structure["edges"] = graph.edges

        if hasattr(graph, "_compiled"):
            compiled = graph._compiled
            if hasattr(compiled, "nodes"):
                structure["nodes"] = list(compiled.nodes.keys())

    except Exception as e:
        print(f"Warning: Could not fully extract graph structure: {e}")

    return structure


def to_safe_python_identifier(name: str) -> str:
    """Convert arbitrary node names into safe Python identifiers for test methods."""
    safe = re.sub(r"\W+", "_", name).strip("_")
    if not safe:
        safe = "node"
    if safe[0].isdigit():
        safe = f"node_{safe}"
    return safe


def generate_pytest_tests(structure: Dict[str, Any], graph_module: str, graph_attr: str) -> str:
    """Generate pytest test cases."""
    nodes = structure.get("nodes", [])

    test_code = f'''"""
Auto-generated test cases for {graph_module}.{graph_attr}

Generated by generate_test_cases.py
Edit these tests to add specific assertions and test data.
"""

import pytest
from {graph_module} import {graph_attr}


@pytest.fixture
def graph():
    """Fixture providing the compiled graph."""
    return {graph_attr}


@pytest.fixture
def mock_llm(monkeypatch):
    """Fixture for mocking LLM responses."""
    # TODO: Implement LLM mocking
    # See mock_llm_responses.py for helpers
    pass


class TestGraphStructure:
    """Test the graph structure and configuration."""

    def test_graph_compiles(self, graph):
        """Test that the graph compiles without errors."""
        assert graph is not None

    def test_graph_has_nodes(self, graph):
        """Test that the graph has the expected nodes."""
        expected_nodes = {repr(nodes)}
        # TODO: Verify actual nodes match expected
        assert len(expected_nodes) > 0


'''

    # Generate node tests
    if nodes:
        test_code += f'''
class TestNodes:
    """Test individual node functions."""

'''
        for node in nodes:
            safe_node = to_safe_python_identifier(node)
            test_code += f'''    def test_{safe_node}_node(self, graph):
        """Test {node} node execution."""
        # TODO: Create appropriate test state
        test_state = {{}}

        # TODO: Execute node and verify output
        # result = graph.nodes["{node}"](test_state)
        # assert result is not None
        pass

'''

    # Generate end-to-end tests
    test_code += '''
class TestEndToEnd:
    """Test complete graph execution flows."""

    def test_basic_execution(self, graph):
        """Test basic graph execution with minimal input."""
        # TODO: Create test input
        test_input = {"messages": []}

        # TODO: Execute graph
        # result = graph.invoke(test_input)
        # assert result is not None
        pass

    def test_execution_with_real_llm(self, graph):
        """Test graph execution with real LLM (integration test)."""
        pytest.skip("Integration test - run with --integration flag")

        # TODO: Create realistic test input
        test_input = {"messages": []}

        # TODO: Execute and verify
        # result = graph.invoke(test_input)
        pass

    def test_execution_with_mock_llm(self, graph, mock_llm):
        """Test graph execution with mocked LLM responses."""
        # TODO: Configure mock LLM behavior
        # TODO: Execute graph
        # TODO: Verify the graph flow is correct
        pass


class TestErrorHandling:
    """Test error handling and edge cases."""

    def test_empty_input(self, graph):
        """Test graph behavior with empty input."""
        # TODO: Test empty input handling
        pass

    def test_invalid_input(self, graph):
        """Test graph behavior with invalid input."""
        # TODO: Test invalid input handling
        pass

    def test_llm_error_handling(self, graph):
        """Test graph behavior when LLM calls fail."""
        # TODO: Mock LLM to raise errors
        # TODO: Verify graceful error handling
        pass
'''

    return test_code


def generate_unittest_tests(structure: Dict[str, Any], graph_module: str, graph_attr: str) -> str:
    """Generate unittest test cases."""
    nodes = structure.get("nodes", [])

    test_code = f'''"""
Auto-generated test cases for {graph_module}.{graph_attr}

Generated by generate_test_cases.py
Edit these tests to add specific assertions and test data.
"""

import unittest
from {graph_module} import {graph_attr}


class TestGraphStructure(unittest.TestCase):
    """Test the graph structure and configuration."""

    def setUp(self):
        """Set up test fixtures."""
        self.graph = {graph_attr}

    def test_graph_compiles(self):
        """Test that the graph compiles without errors."""
        self.assertIsNotNone(self.graph)

    def test_graph_has_nodes(self):
        """Test that the graph has the expected nodes."""
        expected_nodes = {repr(nodes)}
        # TODO: Verify actual nodes match expected
        self.assertGreater(len(expected_nodes), 0)


'''

    # Generate node tests
    if nodes:
        test_code += f'''
class TestNodes(unittest.TestCase):
    """Test individual node functions."""

    def setUp(self):
        """Set up test fixtures."""
        self.graph = {graph_attr}

'''
        for node in nodes:
            safe_node = to_safe_python_identifier(node)
            test_code += f'''    def test_{safe_node}_node(self):
        """Test {node} node execution."""
        # TODO: Create appropriate test state
        test_state = {{}}

        # TODO: Execute node and verify output
        # result = self.graph.nodes["{node}"](test_state)
        # self.assertIsNotNone(result)
        pass

'''

    # Generate end-to-end tests
    test_code += '''
class TestEndToEnd(unittest.TestCase):
    """Test complete graph execution flows."""

    def setUp(self):
        """Set up test fixtures."""
        self.graph = ''' + graph_attr + '''

    def test_basic_execution(self):
        """Test basic graph execution with minimal input."""
        # TODO: Create test input
        test_input = {"messages": []}

        # TODO: Execute graph
        # result = self.graph.invoke(test_input)
        # self.assertIsNotNone(result)
        pass

    def test_execution_with_real_llm(self):
        """Test graph execution with real LLM (integration test)."""
        self.skipTest("Integration test")

        # TODO: Create realistic test input
        # TODO: Execute and verify
        pass


if __name__ == "__main__":
    unittest.main()
'''

    return test_code


def main():
    parser = argparse.ArgumentParser(
        description="Generate test cases from LangGraph graph structure"
    )
    parser.add_argument(
        "graph_module",
        help="Python module path to graph (e.g., my_agent.graph or my_agent:graph)",
    )
    parser.add_argument(
        "--output",
        "-o",
        default="tests",
        help="Output directory for test files (default: tests/)",
    )
    parser.add_argument(
        "--framework",
        "-f",
        choices=["pytest", "unittest"],
        default="pytest",
        help="Test framework to use (default: pytest)",
    )

    args = parser.parse_args()

    # Load the graph
    print(f"Loading graph from {args.graph_module}...")
    graph, module_name, attr_name = load_graph_from_module(args.graph_module)

    # Extract structure
    print("Extracting graph structure...")
    structure = extract_graph_structure(graph)

    print(f"Found {len(structure['nodes'])} nodes")

    # Generate test code
    print(f"Generating {args.framework} test cases...")
    if args.framework == "pytest":
        test_code = generate_pytest_tests(structure, module_name, attr_name)
        filename = f"test_{attr_name}_pytest.py"
    else:
        test_code = generate_unittest_tests(structure, module_name, attr_name)
        filename = f"test_{attr_name}_unittest.py"

    # Write to file
    output_dir = Path(args.output)
    output_dir.mkdir(parents=True, exist_ok=True)

    output_file = output_dir / filename
    output_file.write_text(test_code)

    print(f"\nâœ… Test cases generated: {output_file}")
    print("\nNext steps:")
    print("1. Review the generated tests")
    print("2. Add specific test data and assertions")
    print("3. Implement LLM mocking as needed")
    if args.framework == "pytest":
        print(f"4. Run tests: pytest {output_file}")
    else:
        print(f"4. Run tests: python -m unittest {output_file}")


if __name__ == "__main__":
    main()
